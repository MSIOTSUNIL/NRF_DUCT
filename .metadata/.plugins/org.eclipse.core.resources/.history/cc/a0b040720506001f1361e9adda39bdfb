/*
 * utility.c
 *
 *  Created on: Apr 29, 2024
 *      Author: sunil
 */

#include "utility.h"
extern UART_HandleTypeDef huart1;

void Manage_NRF_Data() {
	char received_data_from_gateway[50] = "";
	NRF24_read(received_data_from_gateway, 5); //store received data

	//copy the 3rd byte, it is the command
	char rcvd_command;
	rcvd_command = received_data_from_gateway[2];

	//commands
	char set_temperature = '0';
	char read_temperature = '1';
}

void Print_Debug_Data(char *Debug_Msg) {
	HAL_UART_Transmit(&huart1, (const uint8_t*) Debug_Msg, strlen(Debug_Msg),
			200);
}
void Manage_Received_Data_From_UART(uint8_t UART_DATA[], size_t data_length) {
// Check if the first element is '*'
	if (data_length > 0 && UART_DATA[0] == '*') {

//IF THE COMAMND IS TO ERASE FDLASH [It will erase the next three page, which contain the data ]
		if (strncmp((char*) &UART_DATA[1], "ERASE_NRF_DATA", 14) == 0) {
			//Erase FLASH_ADDR_4_No_Of_Polling_Node
			bool status = ee_format_page(FLASH_ADDR_START_PG_29_USER_VAR, 4);
			if (!status) {
				Print_Debug_Data(
						(char*) "[ERASE FLASH ERROR] UNABLE TO ERASE \n");
			} else {
				Print_Debug_Data(
						(char*) "[ERASE FLASH ] FLASH ERASED SUCCESFULLY \n");
			}
		}

//IF THE COMAMND IS TO STORE NRF CHANNEL
		if (strncmp((char*) &UART_DATA[1], "NRF_CH:", 7) == 0) {
			//if the condition meet, then the next two byte is the channel
			uint8_t nrfChannel[2];
			nrfChannel[0] = UART_DATA[8];
			nrfChannel[1] = UART_DATA[9];
			// Convert ASCII characters to numeric values
			uint8_t highValue = nrfChannel[0] - '0';
			uint8_t lowValue = nrfChannel[1] - '0';
			// Combine the digits into a single uint8_t
			uint8_t nrfChannel_8_t = (highValue * 10) + lowValue;
			if (!ee_write_16(FLASH_ADDR_4_Self_Channel, nrfChannel_8_t)) {
				Print_Debug_Data(
						(char*) "[ERROR WRITING FLASH] UNABLE TO WRITE CHANNEL Variable\n");
			} else {
				Print_Debug_Data(
						(char*) "[Writing Channel] Channel Written SUCCESFULLY \n");
			}
		}
//IF THE COMAMND IS TO STORE NRF PIPE ADDRESS
		if (strncmp((char*) &UART_DATA[1], "NRF_PIPE_ADDR:", 14) == 0) {
			// If the condition is met, copy the next two bytes to another array
			uint8_t PIPE_Addr[2];
			PIPE_Addr[0] = UART_DATA[15];
			PIPE_Addr[1] = UART_DATA[16];
			//process the command

			//STORE THE NODE ID, like 01 or 02, which will be required for REPLY
			uint16_t DEVICE_ADDRESS = (PIPE_Addr[1] << 8) | PIPE_Addr[0];
			if (!ee_write_16(FLASH_ADDR_4_DEVICE_ID, DEVICE_ADDRESS)) {
				Print_Debug_Data(
						(char*) "[ERROR WRITING FLASH] UNABLE TO WRITE DEVICE ID Variable\n");
			} else {
				Print_Debug_Data(
						(char*) "[Writing DEVICE ID] DEVICE ID Written SUCCESFULLY \n");
			}

			HAL_Delay(100);

			// Convert ASCII characters to numeric values
			uint8_t highValue = PIPE_Addr[0] - '0';
			uint8_t lowValue = PIPE_Addr[1] - '0';
			// Combine the digits into a single uint8_t
			uint8_t nrf_8_t = (highValue * 10) + lowValue;
			//copy the gateway code of finding address, and save the address
			uint64_t NRF_Pipe_Addr = Get_Pipe_Address(nrf_8_t);
			//WRITE IT EEPROM
			if (!ee_write_64(FLASH_ADDR_4_PIPE_ADDR_FOR_NRF, NRF_Pipe_Addr)) {
				Print_Debug_Data(
						(char*) "[UART CB] UNABLE TO WRITE NRF PIPE ADDRES\n");
			} else {
				Print_Debug_Data(
						(char*) "[UART CB] VALID ADDRESS FOUND AND IS SAVED INTO THE EMULATED EEPROM\n");
			}
		}
//IF THE COMMAND IS TO RESTART STM32
		if (strncmp((char*) &UART_DATA[1], "RESTART", 7) == 0) {
			NVIC_SystemReset();
		}
	}
}
